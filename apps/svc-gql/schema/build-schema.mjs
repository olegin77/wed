#!/usr/bin/env node
import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const SCHEMA_DIR = __dirname;
const OUTPUT_FILE = path.join(SCHEMA_DIR, "schema.graphql");

/**
 * Reads all `.gql` files inside the schema directory, normalises whitespace and
 * concatenates them into a single gateway schema. This keeps the per-domain
 * SDL files manageable while exposing a single artifact to consumers.
 */
export async function buildSchema() {
const SAFE_FILENAME = /^[A-Za-z0-9_.-]+$/;

const entries = await fs.readdir(SCHEMA_DIR, { withFileTypes: true });
  const gqlFiles = entries
    .filter((entry) => entry.isFile() && entry.name.endsWith(".gql") && SAFE_FILENAME.test(entry.name))
    .map((entry) => entry.name)
    .sort();

  if (gqlFiles.length === 0) {
    throw new Error("No .gql files found in schema directory");
  }

  const parts = [];
  for (const file of gqlFiles) {
    const absolute = path.join(SCHEMA_DIR, file);
    // eslint-disable-next-line security/detect-non-literal-fs-filename -- filenames are whitelisted via SAFE_FILENAME regex above.
    const contents = await fs.readFile(absolute, "utf8");
    parts.push(`# Source: ${file}\n${contents.trim()}\n`);
  }

  const banner = "# Auto-generated by build-schema.mjs - do not edit manually\n";
  const body = parts.join("\n");
  await fs.writeFile(OUTPUT_FILE, `${banner}\n${body}`);
  return { output: OUTPUT_FILE, sources: gqlFiles };
}

if (process.argv[1] === __filename) {
  buildSchema()
    .then(({ output, sources }) => {
      console.log(`Schema built at ${output} from ${sources.length} SDL files.`);
    })
    .catch((error) => {
      console.error("Failed to build schema", error);
      process.exitCode = 1;
    });
}
